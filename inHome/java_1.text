// (참고)나는 C++을 주 언어로 사용하다가, JAVA에 입문하고 있다. 그래서 C++을 베이스로 자바를 바로보고 있다.

1. 자바의 변수 생성에 대해 이해하기
-> 자바는 8가지 (boolean, byte, short, int, long, float, double, char)을 제외하면 주소값을 저장하는 변수를 생성한다.
ex) string, 배열

2. 배열의 경우 주소값을 저장하는 변수를 생성하고, 그 변수에 동적으로 할당한 배열의 공간에 해당하는 주소를 담는다.
-> 그렇기 때문에 multi_array 같은 경우 c++의 배열과는 다르게 일부 list의 형식을 따른다.

    int[]a1 = {1};
    int[]a2 = {2,3};
    int[]a3 = {4,5,6};
    int[][] arr1 = {a1,a2,a3};

-> 대표적인 예시이다. arr1은 하나의 주소를 저장하는 변수를 가진다. 이 변수는 주소를 저장하는 일차원 배열을 가리킨다.
-> 이러한 일차원 배열안에는 각각이 a1, a2, a3를 가리키는 주소가 저장되어 있다.

배열을 동적으로 선언하는 자바의 특성을 반영한 것 같다. 개인적으로 c++의 배열의 특성인 cpu locality 에서 조금 손해보는 것이 아닌가 생각한다.

자바의 배열에 대한 나의 생각 :
C++은 극단적인 locality 효율을 위해 하나의 배열이 쭉 이어진다. 
그러나 JAVA의 경우 각 배열이 list의 형식을 띄기 때문에 다른 차원의 배열을 탐색할때 일부 locality가 깨지고 cash memory에 새롭게 주소를 저장한다.

이는 JAVA의 극단적일 정도로 OOP를 지향했기 때문이라 생각한다. C++의 경우 객체지향언어라고 하지만 사실 사용자가 고생하면 모든 철학을 적용 가능한 언어이다. 그러나 JAVA의 경우 철저하게 객체지향을 따르고 있다.
나는 이러한 점이 두 언어의 배열을 다르게 만들었다고 생각한다.
JAVA 배열이 C++과 다른 점 
1. C++과 다르게 각 차원의 사이즈가 다른 배열을 만들 수 있다. -> a1은 size가 1이고, a2는 size가 2이다.
2. C++과 비교해 저장공간을 일부 더 사용한다. (당장 각 배열의 주소를 저장하는 변수를 여러개 더 생성한다.)
3. C++과 비교해서 cashing과정에서 약간의 손해를 본다.

동적으로 생성하기 때문에 유용할 수 있는 방법이며, 2번 3번의 단점이 크지 않을 것으로 보임 / 1번은 확실히 장점이 될 수 있어 보임
